---
title: Invoke ChatKit methods
description: Call ChatKit methods for sending actions, messages, and refresh requests.
---

import { TabItem, Tabs } from '@astrojs/starlight/components';

Call ChatKit methods from your app when you need to steer ChatKit outside the normal render flow—sending a user message, forwarding an action, or forcing a refresh. The same helpers exist on `useChatKit` and the `<openai-chatkit>` web component.

<Tabs syncKey="methods-target">
<TabItem label="React">

```tsx
import { ChatKit, useChatKit } from '@openai/chatkit-react';

export function Inbox() {
  const {
    control,
    sendCustomAction,
    sendUserMessage,
    fetchUpdates,
    setThreadId,
    setComposerValue,
    focusComposer,
  } = useChatKit({
    // ...
  });

  return <ChatKit control={control} className="h-[600px]" />;
}
```

</TabItem>
<TabItem label="Web component">

```ts
const chatkit = document.getElementById('my-chat') as OpenAIChatKit;

await chatkit.sendCustomAction({ type: 'refresh-dashboard', payload: { page: 'settings' } });
await chatkit.sendUserMessage({ text: 'Hello there!' });
await chatkit.fetchUpdates();
await chatkit.setThreadId('thread_123');
await chatkit.setComposerValue({ text: 'Draft message' });
await chatkit.focusComposer();
```

</TabItem>
</Tabs>

## Programmatically set or send a user message

`setComposerValue({ text, reply, attachments })`  
Prefills the composer without sending. Use it to drop in suggested replies, recover an autosave, or pre-load attachments before the user clicks Send.

`sendUserMessage({ text, reply?, attachments?, newThread? })`  
Submits a message immediately, just as if the user pressed Send. Pass `newThread: true` to start a fresh conversation instead of continuing the current one.

Common cases:
- Fire a message after speech-to-text completes instead of waiting for another click.
- Trigger a templated follow-up (for example, “Summarize this call”) from a custom button outside ChatKit.
- Kick off a new chat when a workflow finishes by sending the first message with `newThread: true`.

## Trigger a response stream without a user message

Use `sendCustomAction(action, itemId?)` to dispatch an arbitrary action payload back to your backend, optionally namespaced to a widget item ID.

Your backend can treat this like any other ChatKit action: run tools, update thread state, and stream a response that appears in the chat. This is useful for “system” events (refresh a dashboard, retry a tool) that should not show up as user-authored messages.

## Sync ChatKit state after out-of-band updates

`fetchUpdates()` requests new events from your backend immediately instead of waiting for the normal polling cadence. Call this after mutating the thread outside of ChatKit (for example, importing history, locking a thread via an admin endpoint, or resolving a tool request server-side).

## Change the active thread

`setThreadId(threadId: string | null)`  
Loads an existing thread or passes `null` to start a new draft conversation. Use it when a user picks a thread from your own inbox list, or when you want a “New chat” button outside the ChatKit UI.

## Programmatically focus the composer

`focusComposer()`  
Focuses the ChatKit composer input. The promise resolves once the focus request is delivered. On mobile browsers, programmatic focus may be blocked outside user gestures.


## Notes:

All methods return `Promise<void>` and reject if invoked while ChatKit is busy (for example, loading a thread or streaming a response).
